/* -----------------------------------------------------------------------------
 * csharp.swg
 *
 * C# typemaps
 * ----------------------------------------------------------------------------- */

%include <csharphead.swg>

/* The ctype, imtype and cstype typemaps work together and so there should be one of each. 
 * The ctype typemap contains the PInvoke type used in the PInvoke (C/C++) code. 
 * The imtype typemap contains the C# type used in the intermediary class. 
 * The cstype typemap contains the C# type used in the C# proxy classes, type wrapper classes and module class. */

/* alaqil 3 no longer inserts using directives into generated C# code. For backwards compatibility, the alaqil2_CSHARP
   macro can be defined to have alaqil 3 generate using directives similar to those generated by alaqil 2. */
#ifdef alaqil2_CSHARP

%typemap(csimports)                   alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) "\nusing global::System;\nusing global::System.Runtime.InteropServices;\n"

%pragma(csharp) moduleimports=%{
using global::System;
using global::System.Runtime.InteropServices;
%}

%pragma(csharp) imclassimports=%{
using global::System;
using global::System.Runtime.InteropServices;
%}

#endif


/* Fragments */
%fragment("alaqil_PackData", "header") {
/* Pack binary data into a string */
alaqilINTERN char * alaqil_PackData(char *c, void *ptr, size_t sz) {
  static const char hex[17] = "0123456789abcdef";
  const unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu =  u + sz;
  for (; u != eu; ++u) {
    unsigned char uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}
}

%fragment("alaqil_UnPackData", "header") {
/* Unpack binary data from a string */
alaqilINTERN const char * alaqil_UnpackData(const char *c, void *ptr, size_t sz) {
  unsigned char *u = (unsigned char *) ptr;
  const unsigned char *eu = u + sz;
  for (; u != eu; ++u) {
    char d = *(c++);
    unsigned char uu;
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    else 
      return (char *) 0;
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    else 
      return (char *) 0;
    *u = uu;
  }
  return c;
}
}

/* Primitive types */
%typemap(ctype) bool,               const bool &               "unsigned int"
%typemap(ctype) char,               const char &               "char"
%typemap(ctype) signed char,        const signed char &        "signed char"
%typemap(ctype) unsigned char,      const unsigned char &      "unsigned char"
%typemap(ctype) short,              const short &              "short"
%typemap(ctype) unsigned short,     const unsigned short &     "unsigned short"
%typemap(ctype) int,                const int &                "int"
%typemap(ctype) unsigned int,       const unsigned int &       "unsigned int"
%typemap(ctype) long,               const long &               "long"
%typemap(ctype) unsigned long,      const unsigned long &      "unsigned long"
%typemap(ctype) long long,          const long long &          "long long"
%typemap(ctype) unsigned long long, const unsigned long long & "unsigned long long"
%typemap(ctype) float,              const float &              "float"
%typemap(ctype) double,             const double &             "double"
%typemap(ctype) void                                           "void"

%typemap(imtype) bool,               const bool &               "bool"
%typemap(imtype) char,               const char &               "char"
%typemap(imtype) signed char,        const signed char &        "sbyte"
%typemap(imtype) unsigned char,      const unsigned char &      "byte"
%typemap(imtype) short,              const short &              "short"
%typemap(imtype) unsigned short,     const unsigned short &     "ushort"
%typemap(imtype) int,                const int &                "int"
%typemap(imtype) unsigned int,       const unsigned int &       "uint"
%typemap(imtype) long,               const long &               "int"
%typemap(imtype) unsigned long,      const unsigned long &      "uint"
%typemap(imtype) long long,          const long long &          "long"
%typemap(imtype) unsigned long long, const unsigned long long & "ulong"
%typemap(imtype) float,              const float &              "float"
%typemap(imtype) double,             const double &             "double"
%typemap(imtype) void                                           "void"

%typemap(cstype) bool,               const bool &               "bool"
%typemap(cstype) char,               const char &               "char"
%typemap(cstype) signed char,        const signed char &        "sbyte"
%typemap(cstype) unsigned char,      const unsigned char &      "byte"
%typemap(cstype) short,              const short &              "short"
%typemap(cstype) unsigned short,     const unsigned short &     "ushort"
%typemap(cstype) int,                const int &                "int"
%typemap(cstype) unsigned int,       const unsigned int &       "uint"
%typemap(cstype) long,               const long &               "int"
%typemap(cstype) unsigned long,      const unsigned long &      "uint"
%typemap(cstype) long long,          const long long &          "long"
%typemap(cstype) unsigned long long, const unsigned long long & "ulong"
%typemap(cstype) float,              const float &              "float"
%typemap(cstype) double,             const double &             "double"
%typemap(cstype) void                                           "void"

%typemap(ctype) char *, char *&, char[ANY], char[]   "char *"
%typemap(imtype) char *, char *&, char[ANY], char[]   "string"
%typemap(cstype) char *, char *&, char[ANY], char[]   "string"

/* Non primitive types */
%typemap(ctype) alaqilTYPE "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE "$&csclassname"

%typemap(ctype) alaqilTYPE [] "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE [] "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE [] "$csclassname"

%typemap(ctype) alaqilTYPE * "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE * "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE * "$csclassname"

%typemap(ctype) alaqilTYPE & "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE & "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE & "$csclassname"

%typemap(ctype) alaqilTYPE && "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE && "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE && "$csclassname"

/* pointer to a class member */
%typemap(ctype) alaqilTYPE (CLASS::*) "char *"
%typemap(imtype) alaqilTYPE (CLASS::*) "string"
%typemap(cstype) alaqilTYPE (CLASS::*) "$csclassname"

/* The following are the in and out typemaps. These are the PInvoke code generating typemaps for converting from C# to C and visa versa. */

/* primitive types */
%typemap(in) bool
%{ $1 = $input ? true : false; %}

%typemap(directorout) bool
%{ $result = $input ? true : false; %}

%typemap(csdirectorin) bool "$iminput"
%typemap(csdirectorout) bool "$cscall"

%typemap(in) char, 
             signed char, 
             unsigned char, 
             short, 
             unsigned short, 
             int, 
             unsigned int, 
             long, 
             unsigned long, 
             long long, 
             unsigned long long, 
             float, 
             double
%{ $1 = ($1_ltype)$input; %}

%typemap(directorout) char, 
             signed char, 
             unsigned char, 
             short, 
             unsigned short, 
             int, 
             unsigned int, 
             long, 
             unsigned long, 
             long long, 
             unsigned long long, 
             float, 
             double
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) bool               "$input = $1;"
%typemap(directorin) char               "$input = $1;"
%typemap(directorin) signed char        "$input = $1;"
%typemap(directorin) unsigned char      "$input = $1;"
%typemap(directorin) short              "$input = $1;"
%typemap(directorin) unsigned short     "$input = $1;"
%typemap(directorin) int                "$input = $1;"
%typemap(directorin) unsigned int       "$input = $1;"
%typemap(directorin) long               "$input = $1;"
%typemap(directorin) unsigned long      "$input = (unsigned long)$1;"
%typemap(directorin) long long          "$input = $1;"
%typemap(directorin) unsigned long long "$input = $1;"
%typemap(directorin) float              "$input = $1;"
%typemap(directorin) double             "$input = $1;"

%typemap(csdirectorin) char, 
                       signed char, 
                       unsigned char, 
                       short, 
                       unsigned short, 
                       int, 
                       unsigned int, 
                       long, 
                       unsigned long, 
                       long long, 
                       unsigned long long, 
                       float, 
                       double
  "$iminput"

%typemap(csdirectorout) char, 
                        signed char, 
                        unsigned char, 
                        short, 
                        unsigned short, 
                        int, 
                        unsigned int, 
                        long, 
                        unsigned long, 
                        long long, 
                        unsigned long long, 
                        float, 
                        double
  "$cscall"

%typemap(out) bool               %{ $result = $1; %}
%typemap(out) char               %{ $result = $1; %}
%typemap(out) signed char        %{ $result = $1; %}
%typemap(out) unsigned char      %{ $result = $1; %}
%typemap(out) short              %{ $result = $1; %}
%typemap(out) unsigned short     %{ $result = $1; %}
%typemap(out) int                %{ $result = $1; %}
%typemap(out) unsigned int       %{ $result = $1; %}
%typemap(out) long               %{ $result = $1; %}
%typemap(out) unsigned long      %{ $result = (unsigned long)$1; %}
%typemap(out) long long          %{ $result = $1; %}
%typemap(out) unsigned long long %{ $result = $1; %}
%typemap(out) float              %{ $result = $1; %}
%typemap(out) double             %{ $result = $1; %}

/* char * - treat as String */
%typemap(in) char * %{ $1 = ($1_ltype)$input; %}
%typemap(out) char * %{ $result = alaqil_csharp_string_callback((const char *)$1); %}
%typemap(directorout, warning=alaqilWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) char * %{ $result = ($1_ltype)$input; %}
%typemap(directorin) char * %{ $input = alaqil_csharp_string_callback((const char *)$1); %}
%typemap(csdirectorin) char * "$iminput"
%typemap(csdirectorout) char * "$cscall"

/* char *& - treat as String */
%typemap(in) char *& ($*1_ltype temp = 0) %{ 
  temp = ($*1_ltype)$input;
  $1 = &temp;
%}
%typemap(out) char *& %{ if ($1) $result = alaqil_csharp_string_callback((const char *)*$1); %}

%typemap(out, null="") void ""
%typemap(csdirectorin) void "$iminput"
%typemap(csdirectorout) void "$cscall"
%typemap(directorin) void ""

/* primitive types by const reference */
%typemap(in) const bool & ($*1_ltype temp)
%{ temp = $input ? true : false; 
   $1 = &temp; %}

%typemap(directorout,warning=alaqilWARN_TYPEMAP_THREAD_UNSAFE_MSG) const bool &
%{ static $*1_ltype temp;
   temp = $input ? true : false; 
   $result = &temp; %}

%typemap(csdirectorin) const bool & "$iminput"
%typemap(csdirectorout) const bool & "$cscall"

%typemap(in) const char & ($*1_ltype temp), 
             const signed char & ($*1_ltype temp), 
             const unsigned char & ($*1_ltype temp), 
             const short & ($*1_ltype temp), 
             const unsigned short & ($*1_ltype temp), 
             const int & ($*1_ltype temp), 
             const unsigned int & ($*1_ltype temp), 
             const long & ($*1_ltype temp), 
             const unsigned long & ($*1_ltype temp), 
             const long long & ($*1_ltype temp), 
             const unsigned long long & ($*1_ltype temp), 
             const float & ($*1_ltype temp), 
             const double & ($*1_ltype temp)
%{ temp = ($*1_ltype)$input; 
   $1 = &temp; %}

%typemap(directorout,warning=alaqilWARN_TYPEMAP_THREAD_UNSAFE_MSG) const char &,
             const signed char &,
             const unsigned char &,
             const short &,
             const unsigned short &,
             const int &,
             const unsigned int &,
             const long &,
             const unsigned long &,
             const long long &,
             const unsigned long long &,
             const float &,
             const double &
%{ static $*1_ltype temp;
   temp = ($*1_ltype)$input; 
   $result = &temp; %}

%typemap(directorin) const bool &           "$input = $1;"
%typemap(directorin) const char &           "$input = $1;"
%typemap(directorin) const signed char &    "$input = $1;"
%typemap(directorin) const unsigned char &  "$input = $1;"
%typemap(directorin) const short &          "$input = $1;"
%typemap(directorin) const unsigned short & "$input = $1;"
%typemap(directorin) const int &            "$input = $1;"
%typemap(directorin) const unsigned int &   "$input = $1;"
%typemap(directorin) const long &           "$input = $1;"
%typemap(directorin) const unsigned long &  "$input = $1;"
%typemap(directorin) const long long &      "$input = $1;"
%typemap(directorin) const unsigned long long & "$input = $1;"
%typemap(directorin) const float &          "$input = $1;"
%typemap(directorin) const double &         "$input = $1;"

%typemap(csdirectorin) const char & ($*1_ltype temp), 
                       const signed char & ($*1_ltype temp), 
                       const unsigned char & ($*1_ltype temp), 
                       const short & ($*1_ltype temp), 
                       const unsigned short & ($*1_ltype temp), 
                       const int & ($*1_ltype temp), 
                       const unsigned int & ($*1_ltype temp), 
                       const long & ($*1_ltype temp), 
                       const unsigned long & ($*1_ltype temp), 
                       const long long & ($*1_ltype temp), 
                       const unsigned long long & ($*1_ltype temp), 
                       const float & ($*1_ltype temp), 
                       const double & ($*1_ltype temp)
  "$iminput"

%typemap(csdirectorout) const char & ($*1_ltype temp), 
                        const signed char & ($*1_ltype temp), 
                        const unsigned char & ($*1_ltype temp), 
                        const short & ($*1_ltype temp), 
                        const unsigned short & ($*1_ltype temp), 
                        const int & ($*1_ltype temp), 
                        const unsigned int & ($*1_ltype temp), 
                        const long & ($*1_ltype temp), 
                        const unsigned long & ($*1_ltype temp), 
                        const long long & ($*1_ltype temp), 
                        const unsigned long long & ($*1_ltype temp), 
                        const float & ($*1_ltype temp), 
                        const double & ($*1_ltype temp)
  "$cscall"


%typemap(out) const bool &               %{ $result = *$1; %}
%typemap(out) const char &               %{ $result = *$1; %}
%typemap(out) const signed char &        %{ $result = *$1; %}
%typemap(out) const unsigned char &      %{ $result = *$1; %}
%typemap(out) const short &              %{ $result = *$1; %}
%typemap(out) const unsigned short &     %{ $result = *$1; %}
%typemap(out) const int &                %{ $result = *$1; %}
%typemap(out) const unsigned int &       %{ $result = *$1; %}
%typemap(out) const long &               %{ $result = *$1; %}
%typemap(out) const unsigned long &      %{ $result = (unsigned long)*$1; %}
%typemap(out) const long long &          %{ $result = *$1; %}
%typemap(out) const unsigned long long & %{ $result = *$1; %}
%typemap(out) const float &              %{ $result = *$1; %}
%typemap(out) const double &             %{ $result = *$1; %}

/* Default handling. Object passed by value. Convert to a pointer */
%typemap(in, canthrow=1) alaqilTYPE ($&1_type argp)
%{ argp = ($&1_ltype)$input; 
   if (!argp) {
     alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "Attempt to dereference null $1_type", 0);
     return $null;
   }
   $1 = *argp; %}

%typemap(directorout) alaqilTYPE
%{ if (!$input) {
     alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "Unexpected null return for type $1_type", 0);
     return $null;
   }
   $result = *($&1_ltype)$input; %}

%typemap(out) alaqilTYPE 
#ifdef __cplusplus
%{ $result = new $1_ltype((const $1_ltype &)$1); %}
#else
{
  $&1_ltype $1ptr = ($&1_ltype) malloc(sizeof($1_ltype));
  memmove($1ptr, &$1, sizeof($1_type));
  $result = $1ptr;
}
#endif

%typemap(directorin) alaqilTYPE 
%{ $input = (void *)new $1_ltype((const $1_ltype &)$1); %}
%typemap(csdirectorin) alaqilTYPE "new $&csclassname($iminput, true)"
%typemap(csdirectorout) alaqilTYPE "$&csclassname.getCPtr($cscall).Handle"

/* Generic pointers and references */
%typemap(in) alaqilTYPE * %{ $1 = ($1_ltype)$input; %}
%typemap(in, fragment="alaqil_UnPackData") alaqilTYPE (CLASS::*) %{ 
  alaqil_UnpackData($input, (void *)&$1, sizeof($1));
%}
%typemap(in, canthrow=1) alaqilTYPE & %{ $1 = ($1_ltype)$input;
  if (!$1) {
    alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "$1_type type is null", 0);
    return $null;
  } %}
%typemap(in, canthrow=1) alaqilTYPE && %{ $1 = ($1_ltype)$input;
  if (!$1) {
    alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "$1_type type is null", 0);
    return $null;
  } %}
%typemap(out) alaqilTYPE * %{ $result = (void *)$1; %} 
%typemap(out, fragment="alaqil_PackData") alaqilTYPE (CLASS::*) %{
  char buf[128];
  char *data = alaqil_PackData(buf, (void *)&$1, sizeof($1));
  *data = '\0';
  $result = alaqil_csharp_string_callback(buf);
%}
%typemap(out) alaqilTYPE & %{ $result = (void *)$1; %} 
%typemap(out) alaqilTYPE && %{ $result = (void *)$1; %} 

%typemap(directorout, warning=alaqilWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) alaqilTYPE *
%{ $result = ($1_ltype)$input; %}
%typemap(directorout, warning=alaqilWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) alaqilTYPE (CLASS::*)
%{ $result = ($1_ltype)$input; %}

%typemap(directorin) alaqilTYPE *
%{ $input = (void *) $1; %}
%typemap(directorin) alaqilTYPE (CLASS::*)
%{ $input = (void *) $1; %}

%typemap(directorout, warning=alaqilWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) alaqilTYPE &
%{ if (!$input) {
     alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "Unexpected null return for type $1_type", 0);
     return $null;
   }
   $result = ($1_ltype)$input; %}
%typemap(directorout, warning=alaqilWARN_TYPEMAP_DIRECTOROUT_PTR_MSG) alaqilTYPE &&
%{ if (!$input) {
     alaqil_CSharpSetPendingExceptionArgument(alaqil_CSharpArgumentNullException, "Unexpected null return for type $1_type", 0);
     return $null;
   }
   $result = ($1_ltype)$input; %}
%typemap(directorin) alaqilTYPE &
%{ $input = ($1_ltype) &$1; %}
%typemap(directorin) alaqilTYPE &&
%{ $input = ($1_ltype) &$1; %}

%typemap(csdirectorin) alaqilTYPE *, alaqilTYPE (CLASS::*) "($iminput == global::System.IntPtr.Zero) ? null : new $csclassname($iminput, false)"
%typemap(csdirectorin) alaqilTYPE & "new $csclassname($iminput, false)"
%typemap(csdirectorin) alaqilTYPE && "new $csclassname($iminput, false)"
%typemap(csdirectorout) alaqilTYPE *, alaqilTYPE (CLASS::*), alaqilTYPE &, alaqilTYPE && "$csclassname.getCPtr($cscall).Handle"

/* Default array handling */
%typemap(in) alaqilTYPE [] %{ $1 = ($1_ltype)$input; %}
%typemap(out) alaqilTYPE [] %{ $result = $1; %} 

/* char arrays - treat as String */
%typemap(in) char[ANY], char[] %{ $1 = ($1_ltype)$input; %}
%typemap(out) char[ANY], char[] %{ $result = alaqil_csharp_string_callback((const char *)$1); %}

%typemap(directorout) char[ANY], char[] %{ $result = ($1_ltype)$input; %}
%typemap(directorin) char[ANY], char[] %{ $input = alaqil_csharp_string_callback((const char *)$1); %}

%typemap(csdirectorin) char[ANY], char[] "$iminput"
%typemap(csdirectorout) char[ANY], char[] "$cscall"


/* Typecheck typemaps - The purpose of these is merely to issue a warning for overloaded C++ functions 
 * that cannot be overloaded in C# as more than one C++ type maps to a single C# type */

%typecheck(alaqil_TYPECHECK_BOOL)
    bool,
    const bool &
    ""

%typecheck(alaqil_TYPECHECK_CHAR)
    char, 
    const char &
    ""

%typecheck(alaqil_TYPECHECK_INT8)
    signed char,
    const signed char &
    ""

%typecheck(alaqil_TYPECHECK_UINT8)
    unsigned char, 
    const unsigned char & 
    ""

%typecheck(alaqil_TYPECHECK_INT16)
    short, 
    const short &
    ""

%typecheck(alaqil_TYPECHECK_UINT16)
    unsigned short, 
    const unsigned short &
    ""

%typecheck(alaqil_TYPECHECK_INT32)
    int, 
    long, 
    const int &, 
    const long &
    ""

%typecheck(alaqil_TYPECHECK_UINT32)
    unsigned int, 
    unsigned long, 
    const unsigned int &, 
    const unsigned long &
    ""

%typecheck(alaqil_TYPECHECK_INT64)
    long long, 
    const long long &
    ""

%typecheck(alaqil_TYPECHECK_UINT64)
    unsigned long long,
    const unsigned long long &
    ""

%typecheck(alaqil_TYPECHECK_FLOAT)
    float,
    const float &
    ""

%typecheck(alaqil_TYPECHECK_DOUBLE)
    double,
    const double &
    ""

%typecheck(alaqil_TYPECHECK_STRING)
    char *,
    char *&,
    char[ANY],
    char[]
    ""

%typecheck(alaqil_TYPECHECK_POINTER)
    alaqilTYPE, 
    alaqilTYPE *, 
    alaqilTYPE &, 
    alaqilTYPE &&, 
    alaqilTYPE *const&, 
    alaqilTYPE [],
    alaqilTYPE (CLASS::*)
    ""

/* Exception handling */

%typemap(throws, canthrow=1) int, 
                 long, 
                 short, 
                 unsigned int, 
                 unsigned long, 
                 unsigned short
%{ char error_msg[256];
   sprintf(error_msg, "C++ $1_type exception thrown, value: %d", $1);
   alaqil_CSharpSetPendingException(alaqil_CSharpApplicationException, error_msg);
   return $null; %}

%typemap(throws, canthrow=1) alaqilTYPE, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE *, alaqilTYPE [ANY]
%{ (void)$1;
   alaqil_CSharpSetPendingException(alaqil_CSharpApplicationException, "C++ $1_type exception thrown");
   return $null; %}

%typemap(throws, canthrow=1) char *
%{ alaqil_CSharpSetPendingException(alaqil_CSharpApplicationException, $1);
   return $null; %}


/* Typemaps for code generation in proxy classes and C# type wrapper classes */

/* The csin typemap is used for converting function parameter types from the type 
 * used in the proxy, module or type wrapper class to the type used in the PInvoke class. */
%typemap(csin)   bool,               const bool &,
                 char,               const char &,
                 signed char,        const signed char &,
                 unsigned char,      const unsigned char &,
                 short,              const short &,
                 unsigned short,     const unsigned short &,
                 int,                const int &,
                 unsigned int,       const unsigned int &,
                 long,               const long &,
                 unsigned long,      const unsigned long &,
                 long long,          const long long &,
                 unsigned long long, const unsigned long long &,
                 float,              const float &,
                 double,             const double &
    "$csinput"
%typemap(csin) char *, char *&, char[ANY], char[] "$csinput"
%typemap(csin) alaqilTYPE "$&csclassname.getCPtr($csinput)"
%typemap(csin) alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [] "$csclassname.getCPtr($csinput)"
%typemap(csin) alaqilTYPE (CLASS::*) "$csclassname.getCMemberPtr($csinput)"

/* The csout typemap is used for converting function return types from the return type
 * used in the PInvoke class to the type returned by the proxy, module or type wrapper class.
 * The $excode special variable is replaced by the excode typemap attribute code if the
 * method can throw any exceptions from unmanaged code, otherwise replaced by nothing. */

// Macro used by the $excode special variable
%define alaqilEXCODE "\n    if ($imclassname.alaqilPendingException.Pending) throw $imclassname.alaqilPendingException.Retrieve();" %enddef
%define alaqilEXCODE2 "\n      if ($imclassname.alaqilPendingException.Pending) throw $imclassname.alaqilPendingException.Retrieve();" %enddef

%typemap(csout, excode=alaqilEXCODE) bool,               const bool &               {
    bool ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) char,               const char &               {
    char ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) signed char,        const signed char &        {
    sbyte ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) unsigned char,      const unsigned char &      {
    byte ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) short,              const short &              {
    short ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) unsigned short,     const unsigned short &     {
    ushort ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) int,                const int &                {
    int ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) unsigned int,       const unsigned int &       {
    uint ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) long,               const long &               {
    int ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) unsigned long,      const unsigned long &      {
    uint ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) long long,          const long long &          {
    long ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) unsigned long long, const unsigned long long & {
    ulong ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) float,              const float &              {
    float ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) double,             const double &             {
    double ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) char *, char *&, char[ANY], char[] {
    string ret = $imcall;$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) void {
    $imcall;$excode
  }
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE {
    $&csclassname ret = new $&csclassname($imcall, true);$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE & {
    $csclassname ret = new $csclassname($imcall, $owner);$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE && {
    $csclassname ret = new $csclassname($imcall, $owner);$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE *, alaqilTYPE [] {
    global::System.IntPtr cPtr = $imcall;
    $csclassname ret = (cPtr == global::System.IntPtr.Zero) ? null : new $csclassname(cPtr, $owner);$excode
    return ret;
  }
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE (CLASS::*) {
    string cMemberPtr = $imcall;
    $csclassname ret = (cMemberPtr == null) ? null : new $csclassname(cMemberPtr, $owner);$excode
    return ret;
  }


/* Properties */
%typemap(csvarin, excode=alaqilEXCODE2) alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) %{
    set {
      $imcall;$excode
    } %}

%typemap(csvarin, excode=alaqilEXCODE2) char *, char *&, char[ANY], char[] %{
    set {
      $imcall;$excode
    } %}

%typemap(csvarout, excode=alaqilEXCODE2) bool,               const bool &               %{
    get {
      bool ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) char,               const char &               %{
    get {
      char ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) signed char,        const signed char &        %{
    get {
      sbyte ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) unsigned char,      const unsigned char &      %{
    get {
      byte ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) short,              const short &              %{
    get {
      short ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) unsigned short,     const unsigned short &     %{
    get {
      ushort ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) int,                const int &                %{
    get {
      int ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) unsigned int,       const unsigned int &       %{
    get {
      uint ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) long,               const long &               %{
    get {
      int ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) unsigned long,      const unsigned long &      %{
    get {
      uint ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) long long,          const long long &          %{
    get {
      long ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) unsigned long long, const unsigned long long & %{
    get {
      ulong ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) float,              const float &              %{
    get {
      float ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) double,             const double &             %{
    get {
      double ret = $imcall;$excode
      return ret;
    } %}


%typemap(csvarout, excode=alaqilEXCODE2) char *, char *&, char[ANY], char[] %{
    get {
      string ret = $imcall;$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) void %{
    get {
      $imcall;$excode
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) alaqilTYPE %{
    get {
      $&csclassname ret = new $&csclassname($imcall, true);$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) alaqilTYPE & %{
    get {
      $csclassname ret = new $csclassname($imcall, $owner);$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) alaqilTYPE && %{
    get {
      $csclassname ret = new $csclassname($imcall, $owner);$excode
      return ret;
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) alaqilTYPE *, alaqilTYPE [] %{
    get {
      global::System.IntPtr cPtr = $imcall;
      $csclassname ret = (cPtr == global::System.IntPtr.Zero) ? null : new $csclassname(cPtr, $owner);$excode
      return ret;
    } %}

%typemap(csvarout, excode=alaqilEXCODE2) alaqilTYPE (CLASS::*) %{
    get {
      string cMemberPtr = $imcall;
      $csclassname ret = (cMemberPtr == null) ? null : new $csclassname(cMemberPtr, $owner);$excode
      return ret;
    } %}

/* Pointer reference typemaps */
%typemap(ctype) alaqilTYPE *const& "void *"
%typemap(imtype, out="global::System.IntPtr") alaqilTYPE *const& "global::System.Runtime.InteropServices.HandleRef"
%typemap(cstype) alaqilTYPE *const& "$*csclassname"
%typemap(csin) alaqilTYPE *const& "$*csclassname.getCPtr($csinput)"
%typemap(csout, excode=alaqilEXCODE) alaqilTYPE *const& {
    global::System.IntPtr cPtr = $imcall;
    $*csclassname ret = (cPtr == global::System.IntPtr.Zero) ? null : new $*csclassname(cPtr, $owner);$excode
    return ret;
  }
%typemap(csvarout, excode=alaqilEXCODE) alaqilTYPE *const& %{
    get {
      global::System.IntPtr cPtr = $imcall;
      $*csclassname ret = (cPtr == global::System.IntPtr.Zero) ? null : new $*csclassname(cPtr, $owner);$excode
      return ret;
    } %}

%typemap(in) alaqilTYPE *const& ($*1_ltype temp = 0)
%{ temp = ($*1_ltype)$input;
   $1 = ($1_ltype)&temp; %}
%typemap(out) alaqilTYPE *const&
%{ $result = (void *)*$1; %} 
%typemap(directorin) alaqilTYPE *const&
%{ $input = (void *) $1; %}
%typemap(directorout, warning=alaqilWARN_TYPEMAP_THREAD_UNSAFE_MSG) alaqilTYPE *const&
%{ static $*1_ltype alaqil_temp;
   alaqil_temp = ($*1_ltype)$input;
   $result = &alaqil_temp; %}
%typemap(csdirectorin) alaqilTYPE *const& "($iminput == global::System.IntPtr.Zero) ? null : new $*csclassname($iminput, false)"
%typemap(csdirectorout) alaqilTYPE *const& "$*csclassname.getCPtr($cscall).Handle"

/* Marshal C/C++ pointer to global::System.IntPtr */
%typemap(ctype) void *VOID_INT_PTR "void *"
%typemap(imtype) void *VOID_INT_PTR "global::System.IntPtr"
%typemap(cstype) void *VOID_INT_PTR "global::System.IntPtr"
%typemap(in) void *VOID_INT_PTR %{ $1 = ($1_ltype)$input; %}
%typemap(out) void *VOID_INT_PTR %{ $result = (void *)$1; %} 
%typemap(csin) void *VOID_INT_PTR "$csinput"
%typemap(csout, excode=alaqilEXCODE) void *VOID_INT_PTR {
    global::System.IntPtr ret = $imcall;$excode
    return ret;
  }
%typemap(csdirectorin) void *VOID_INT_PTR "$iminput"
%typemap(csdirectorout) void *VOID_INT_PTR "$cscall"

/* Typemaps used for the generation of proxy and type wrapper class code */
%typemap(csbase)                      alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) ""
%typemap(csclassmodifiers)            alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) "public class"
%typemap(cscode)                      alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) ""
%typemap(csinterfaces)                alaqilTYPE "global::System.IDisposable"
%typemap(csinterfaces)                          alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) ""
%typemap(csinterfaces_derived)        alaqilTYPE, alaqilTYPE *, alaqilTYPE &, alaqilTYPE &&, alaqilTYPE [], alaqilTYPE (CLASS::*) ""


// csbody typemaps... these are in macros so that the visibility of the methods can be easily changed by users.

%define alaqil_CSBODY_PROXY(PTRCTOR_VISIBILITY, CPTR_VISIBILITY, TYPE...)
// Proxy classes (base classes, ie, not derived classes)
%typemap(csbody) TYPE %{
  private global::System.Runtime.InteropServices.HandleRef alaqilCPtr;
  protected bool alaqilCMemOwn;

  PTRCTOR_VISIBILITY $csclassname(global::System.IntPtr cPtr, bool cMemoryOwn) {
    alaqilCMemOwn = cMemoryOwn;
    alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  CPTR_VISIBILITY static global::System.Runtime.InteropServices.HandleRef getCPtr($csclassname obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.alaqilCPtr;
  }
%}

// Derived proxy classes
%typemap(csbody_derived) TYPE %{
  private global::System.Runtime.InteropServices.HandleRef alaqilCPtr;

  PTRCTOR_VISIBILITY $csclassname(global::System.IntPtr cPtr, bool cMemoryOwn) : base($imclassname.$csclazznamealaqilUpcast(cPtr), cMemoryOwn) {
    alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  CPTR_VISIBILITY static global::System.Runtime.InteropServices.HandleRef getCPtr($csclassname obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.alaqilCPtr;
  }
%}
%enddef

%define alaqil_CSBODY_TYPEWRAPPER(PTRCTOR_VISIBILITY, DEFAULTCTOR_VISIBILITY, CPTR_VISIBILITY, TYPE...)
// Typewrapper classes
%typemap(csbody) TYPE *, TYPE &, TYPE &&, TYPE [] %{
  private global::System.Runtime.InteropServices.HandleRef alaqilCPtr;

  PTRCTOR_VISIBILITY $csclassname(global::System.IntPtr cPtr, bool futureUse) {
    alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  DEFAULTCTOR_VISIBILITY $csclassname() {
    alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
  }

  CPTR_VISIBILITY static global::System.Runtime.InteropServices.HandleRef getCPtr($csclassname obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.alaqilCPtr;
  }
%}

%typemap(csbody) TYPE (CLASS::*) %{
  private string alaqilCMemberPtr;

  PTRCTOR_VISIBILITY $csclassname(string cMemberPtr, bool futureUse) {
    alaqilCMemberPtr = cMemberPtr;
  }

  DEFAULTCTOR_VISIBILITY $csclassname() {
    alaqilCMemberPtr = null;
  }

  CPTR_VISIBILITY static string getCMemberPtr($csclassname obj) {
    return obj.alaqilCMemberPtr;
  }
%}
%enddef

/* Set the default csbody typemaps to use internal visibility.
   Use the macros to change to public if using multiple modules. */
alaqil_CSBODY_PROXY(internal, internal, alaqilTYPE)
alaqil_CSBODY_TYPEWRAPPER(internal, protected, internal, alaqilTYPE)

%typemap(csfinalize) alaqilTYPE %{
  ~$csclassname() {
    Dispose();
  }
%}

%typemap(csconstruct, excode=alaqilEXCODE,directorconnect="\n    alaqilDirectorConnect();") alaqilTYPE %{: this($imcall, true) {$excode$directorconnect
  }
%}

%typemap(csdestruct, methodname="Dispose", methodmodifiers="public") alaqilTYPE {
    lock(this) {
      if (alaqilCPtr.Handle != global::System.IntPtr.Zero) {
        if (alaqilCMemOwn) {
          alaqilCMemOwn = false;
          $imcall;
        }
        alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
    }
  }

%typemap(csdestruct_derived, methodname="Dispose", methodmodifiers="public") alaqilTYPE {
    lock(this) {
      if (alaqilCPtr.Handle != global::System.IntPtr.Zero) {
        if (alaqilCMemOwn) {
          alaqilCMemOwn = false;
          $imcall;
        }
        alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
      global::System.GC.SuppressFinalize(this);
      base.Dispose();
    }
  }

%typemap(directordisconnect, methodname="alaqilDirectorDisconnect") alaqilTYPE %{
  protected void $methodname() {
    alaqilCMemOwn = false;
    $imcall;
  }
%}

/* C# specific directives */
#define %csconst(flag)              %feature("cs:const","flag")
#define %csconstvalue(value)        %feature("cs:constvalue",value)
#define %csenum(wrapapproach)       %feature("cs:enum","wrapapproach")
#define %csmethodmodifiers          %feature("cs:methodmodifiers")
#define %csnothrowexception         %feature("except")
#define %csattributes               %feature("cs:attributes")
#define %proxycode                  %insert("proxycode")

%pragma(csharp) imclassclassmodifiers="class"
%pragma(csharp) moduleclassmodifiers="public class"

/* Some ANSI C typemaps */

%apply unsigned long { size_t };
%apply const unsigned long & { const size_t & };

/* Array reference typemaps */
%apply alaqilTYPE & { alaqilTYPE ((&)[ANY]) }
%apply alaqilTYPE && { alaqilTYPE ((&&)[ANY]) }

/* const pointers */
%apply alaqilTYPE * { alaqilTYPE *const }
%apply alaqilTYPE (CLASS::*) { alaqilTYPE (CLASS::*const) }
%apply alaqilTYPE & { alaqilTYPE (CLASS::*const&) }

/* csharp keywords */
%include <csharpkw.swg>

// Default enum handling
%include <enums.swg>

// For vararg handling in macros, from alaqilmacros.swg
#define %arg(X...) X

/*
// Alternative char * typemaps.
%pragma(csharp) imclasscode=%{
  public class alaqilStringMarshal : global::System.IDisposable {
    public readonly global::System.Runtime.InteropServices.HandleRef alaqilCPtr;
    public alaqilStringMarshal(string str) {
      alaqilCPtr = new global::System.Runtime.InteropServices.HandleRef(this, global::System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi(str));
    }
    public virtual void Dispose() {
      global::System.Runtime.InteropServices.Marshal.FreeHGlobal(alaqilCPtr.Handle);
      global::System.GC.SuppressFinalize(this);
    }
  }
%}

%typemap(imtype, out="global::System.IntPtr") char *, char[ANY], char[]   "global::System.Runtime.InteropServices.HandleRef"
%typemap(out) char *, char[ANY], char[] %{ $result = $1; %}
%typemap(csin) char *, char[ANY], char[] "new $imclassname.alaqilStringMarshal($csinput).alaqilCPtr"
%typemap(csout, excode=alaqilEXCODE) char *, char[ANY], char[] {
    string ret = global::System.Runtime.InteropServices.Marshal.PtrToStringAnsi($imcall);$excode
    return ret;
  }
%typemap(csvarin, excode=alaqilEXCODE2) char *, char[ANY], char[] %{
    set {
      $imcall;$excode
    } %}
%typemap(csvarout, excode=alaqilEXCODE2) char *, char[ANY], char[] %{
    get {
      string ret = global::System.Runtime.InteropServices.Marshal.PtrToStringAnsi($imcall);$excode
      return ret;
    } %}
*/

